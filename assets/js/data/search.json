[ { "title": "Leetcode | 2619. Array Prototype Last, 2620. Counter", "url": "/posts/Leetcode-2619-Array-Prototype-Last/", "categories": "알고리즘", "tags": "Leetcode, Problem Solving, 알고리즘, JS", "date": "2023-06-04 00:00:00 +0900", "snippet": "자바스크립트 easy 2문제를 풀었다.2619. Array Prototype Last자바스크립트 Array 객체의 프로토타입에 last 라는 새로운 메소드를 추가하는 것이 문제. last 함수는 배열의 마지막 값을 리턴한다. 빈 배열이면 -1.간단하게는 삼항 연산자로 해결할 수 있지만, 나는 Nullish coalescing operator ?? 를 사용했다.Array.prototype.last = function() { return this.at(-1) ?? -1};배열에 직접 인덱스로 접근할 때는 음수 인덱싱이 불가능하다. at() 메소드 사용할 때만 가능하다. 여기서 자바스크립트 개념과 연결해볼만 한 부분은 this 객체. Array 프로토타입 내의 메소드들의 this는 실제 데이터를 담고 있는 배열을 가리킨다.2620. Countern이 주어졌을 때, 호출할 때마다 n의 값이 1씩 증가하는 함수를 만들 것. 예시코드를 보면 함수를 리턴하는 함수를 작성해야 한다. 처음 createCounter의 파라미터로 n 을 받고 1씩 증가하는 함수를 리턴한다.호이스팅의 개념을 적용하여 리턴하는 함수에서 바로 상위 함수에서 파라미터로 받은 n을 증가연산하여 리턴한다. 호이스팅은 함수가 선언될 시의 주변 환경값을 기억하는 특징이 있기 때문에 내부 함수의 파라미터로는 아무것도 넘겨주지 않아도 되는 것이다.createCounter(10) 을 호출한 순간 10이 함수 내부적으로 저장되어, counter()로 아무런 파라미터값 없이 호출해도 내부에서는 10을 기억하고 있다./** * @param {number} n * @return {Function} counter */var createCounter = function(n) { return function() { return n++ };};/** * const counter = createCounter(10) * counter() // 10 * counter() // 11 * counter() // 12 */" }, { "title": "Vue | useStore()를 사용하는 이유", "url": "/posts/vue-useStore/", "categories": "Vue", "tags": "Vue, Vuex, 상태관리", "date": "2023-05-29 00:00:00 +0900", "snippet": "Vue에서 store 접근하기보통 프론트앱에서 데이터의 변경을 감지하고 추적하는 상태관리가 필요한 데이터들은 store에 보관하여 사용한다. store 객체를 생성하고 이를 vue app에 전역적으로 등록한다. 그러면 컴포넌트에서 해당 store에 접근하여 데이터를 get, mutation 등등의 작업을 할 수 있다.보통은 store에 접근하는 방법은 다음과 같다. composition api 기준 vue app에 전역적으로 등록한 store를 this를 통해 접근하는 경우setup() { const some = computed(() =&amp;gt; this.$store.getters.something)} store 객체를 직접 다이렉트로 import 하는 경우import {store} from &#39;@/../../store/index.js&#39;setup() { const some = computed(() =&amp;gt; store.getters.something)}기존의 vuex2 또는 vuex3에서는 이렇게 두 가지 방법을 많이 사용한다. vuex4부터는 store에 접근할 수 있는 새로운 api를 지원한다.useStore()store 객체에 접근할 수 있는 Vuex function 이다. vuex에서 임포트해서 사용할수 있다. composition api에서 setup hook에 사용할 수 있다.import { useStore } from &#39;vuex&#39;setup() { const store = useStore() ...}위의 코드는 기존의 this.$store 와 똑같은 기능을 제공한다. 그러나 composition api의 setup 훅에서의 this 는 현재의 인스턴스를 참조하지 않는다. 컴포넌트내의 옵션들이 결정되기 전에 setup hook이 호출되기 때문에 this는 아무런 것도 참조할 수 없게 된다. (undefined를 참조함) 따라서 setup hook에서 store를 접근할 수 있도록 새로 나온 함수가 useStore이다. option api를 사용할 경우는 기존과 같이 this.$store를 사용하면 된다.참고 공식문서에서 소개하는 store에 접근하는 방법" }, { "title": "JS | scoping 유효범위", "url": "/posts/JS-%EB%B3%80%EC%88%98-%EC%9C%A0%ED%9A%A8%EB%B2%94%EC%9C%84/", "categories": "JS", "tags": "JS, Javascript, var, let, const", "date": "2023-02-13 00:00:00 +0900", "snippet": "유효 범위 scoping기본적으로 var 키워드로 선언된 변수는 함수 레벨 스코프이다. 자바스크립트에서는 함수 레벨 스코프 (function scoping)와 블록 레벨 스코프 (block scoping)로 나뉜다. 함수 레벨 스코프 : 변수에 접근할 수 있는 범위가 변수가 선언된 함수로 한정된다. 블록 레벨 스코프 : 변수에 접근할 수 있는 범위가 {} 블록 내부로 한정된다. // function scoping run = function() { if (true) { var bar = &#39;bar&#39; } console.log(bar) } run() // &#39;bar&#39; var은 if 블록이 아닌 함수 내부 전체 에서 접근가능하기 때문에 if 블록이 종료되어도 접근할 수 있다. 따라서 ‘bar’ 출력. // block scoping run = function() { if (true) { let bar = &#39;bar&#39; } console.log(bar) } run() // ReferenceError: bar is not definedlet은 블록 레벨 스코프이기 때문에 if블록 내에서만 유효하다. 따라서 if문 종료후에는 접근할 수 없으므로 에러가 발생한다.var는 함수 레벨 스코프이기 때문에 블록 내부의 변수가 블록 외부에까지 영향을 미칠 수 있다는 점을 알아야 한다. 이는 코드의 추적을 방해하고, 예측하지 못한 결과를 만들 수도 있다. 모든 변수이름을 다 머리 속에 저장하고 코드를 작성하지 않으므로 충분히 중복된 변수명을 사용할 수 있다. 또한, var로 선언한 변수는 전역 객체에 등록된다는 점도 같은 맥락에서 이해할 수 있다.정리하자면, 내가 사용한 변수의 유효범위를 정확하게 제한하거나 예측할 수 없다. 전역 객체에 등록되어 전역변수로 사용된다.Lexical scoping" }, { "title": "JS | 선언과 할당 관점에서 본 호이스팅 개념과 이유", "url": "/posts/JS-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85/", "categories": "JS", "tags": "JS, Javascript, var, let, const, hoisting, 호이스팅", "date": "2023-02-09 00:00:00 +0900", "snippet": "기존의 변수 선언 방식모든 프로그래밍 언어에서의 변수는 선언 -&amp;gt; 할당 -&amp;gt; 사용의 과정을 거친다. 그리고 선언되어있지 않은 변수는 할당도, 사용도 불가능하다. 즉, 사전에 선언이 되어 있어야 사용이 가능하다. 자바스크립트에서는 이러한 과정에서 호이스팅이란 개념이 존재한다.호이스팅 hoisting호이스팅은 코드의 실행 전에, 변수의 선언 관련 정보를 미리 수집하여 실행 전에 변수에 접근할 수 있도록 하는 과정이다. MDN에서는 ‘인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것을 의미’라고 설명하고 있다.보통 호이스팅 관련한 글들을 보면 변수의 선언부를 끌어올린다는 표현을 많이 쓴다. 아마 hoist 라는 단어의 뜻 때문인 것 같다. 무언가를 끌어올린다는 사전적 의미를 갖고 있다. hoist : (noun) an act of raising or lifting something.코드는 순차적이기 때문에 위/아래가 존재한다. 컴파일러/인터프리터는 위에서부터 아래로 순차적으로 코드를 해석한다. 따라서 이미지상으로 하단의(즉, 미래의) 변수들을 상단으로(현재) 끌어올린다는 표현이 이상하지가 않는 것이다. run = function() { console.log(foo) var foo = &#39;foo&#39; // 데이터 선언과 할당이 동시에 이루어진 코드. } run() // &#39;undefined&#39;호이스팅이 발생하여, foo 를 선언하기 이전에 콘솔에 찍어보면 undefined를 출력한다. 컴파일러가 코드를 실행하기 전에, 변수의 선언 정보들만 미리 스캔한다. var foo = &#39;foo&#39; 이 부분에서 선언부분만 수집하게 되어, foo 변수를 메모리에 할당하고 문자열 ‘foo’를 할당하는 부분은 무시하고 디폴트값인 undefined를 할당한다.즉, 해당 변수를 초기화/사용하기도 전에 접근할 수 있다는 점을 조심해야한다.호이스팅의 대상호이스팅의 대상은 변수, 함수, 클래스이다. 여기서는 변수의 선언방식에 초점을 둔다면, var, let, const 이 세가지 방식이 있다. 이 세 가지 방식으로 선언된 변수들 모두 호이스팅이 된다, 하지만 할당 부분에서 차이가 있다. var만 호이스팅의 대상이 된다는 말도 있는데, 내부적으로는 let, const 도 호이스팅이 된다. 즉 실행 전에 정보 수집의 대상이 된다. run = function() { console.log(foo) let foo = &#39;foo&#39; } run() // ReferenceError: Cannot access &#39;foo&#39; before initialization위의 코드에서 foo is not defined 에러가 아니라 Cannot access &#39;foo&#39; before initialization 에러가 나는 것은 foo 변수가 호이스팅의 대상이 되었음을 의미한다. 호이스팅의 대상이 된다는 얘기는 실행 전에 접근할 수 있음을, 엔진이 실행전에 해당 변수의 존재를 알고 있음을 의미한다. 호이스팅이 발생하지 않았다면, 선언하지 않은 변수를 사용하고자 했으므로 foo is not defined 에러가 나야 정상이다. 접근은 가능하나 값이 정의가 되어있지 않았을 뿐이다. var 선언부를 모두 수집한 후에, undefined를 기본값으로 일괄 할당한다. let, const 선언부를 모두 수집한 후에 TDZ 영역에 할당한다. TDZ는 변수 선언 이후와 할당 전의 영역을 의미한다. 선언은 되었지만 할당 전의 변수에 대한 접근을 제한하는 역할이다. 호이스팅 내부 동작 과정결국엔, 호이스팅은 JS 엔진이 코드를 실행하는 과정의 일부이다. 그래서 자바스크립트 코드가 내부적으로 어떤 과정으로 실행되는지의 맥락에서 이해해 볼 필요가 있다. JS엔진 코드를 실행하기 위해 크게 두 가지 단계를 거친다. 실행 컨텍스트 생성 우선, 실행 컨텍스트를 생성한다. 그리고 해당 실행 컨텍스트 내의 코드를 쭉 훑으면서 여기서 사용할 변수들에 대한 정보를 미리 수집한다. 이 실행 컨텍스트 내의 코드를 이따 실행할건데, 어떤 애들로 구성이 되어 있나 한 번 사전 조사를 하는 과정이라고 보면 된다. 굳이 비유하자면, 출석부 호명하는 이미지 떠올리면 된다. 따라서, 변수의 선언부만 읽는다. 각 변수에 대한 값 할당은 임의적으로 undefined 로 할당하고, 나중에 실제로 코드가 실행될 때 코드에 따라 원래 값으로 할당한다. 코드가 실행되기 전 상태는 실행 컨텍스트 내부의 모든 변수는 undefined로 접근할 수 있는 상태가 된다. 코드 실행 사전 수집된 변수 정보를 가지고 코드를 한 줄씩 실행해 나간다. 위의 코드를 인터프리터 입장에서 다시 풀어서 코드로 표현해보자면 아래와 같다. run = function() { (var foo;) // 엔진이 끌어올린 변수 선언부 console.log(foo) foo = &#39;foo&#39; } run()괄호 부분이 엔진이 모든 선언 부분을 처음으로 셋팅한 상태라고 볼 수 있다. 이렇게 사전에 변수에 대한 정보들을 미리 알고 난 이후에 (미리 선언해 둔 다음에) 코드를 실행해나간다.왜 호이스팅 과정이 발생하는 걸까?왜 이렇게 자바스크립트는 성격이 급해서 코드 실행도 전에 변수에 접근할 수 있도록 해주는 걸까? 자바스크립트의 창조주 브렌든 아이크님이 직접 답을 해주신 트윗을 발견했다. 진짜가 나타났다. 질문자님이 내가 가진 궁금증을 다 물어봐주셔서 속이 시원했다. 왜 이렇게 디자인되었는지가 궁금했다.해당 트윗 링크Q : 왜 자바스크립트는 호이스팅을 하나요? 왜 자바스크립트는 그런 방식으로 설계되었나요? 그러한 설계 방식은 무엇의 영향을 받았나요? A : 함수 호이스팅으로 인해 다음 3가지를 할 수 있다. 탑다운 방식의 프로그램 구조 분해 ‘let rec’를 자유롭게 사용하는 것 함수 선언 전에 함수 호출 변수에 대한 호이스팅은 다음 3가지의 의한 의도하지 않은 결과물이다. 함수 호이스팅 블록 레벨 스코프가 아님 1995년에 급하게 작업한 결과 let이 도움이 될 것이다.원래 호이스팅의 목적은 함수였다. 처음엔 함수만을 생각하고 설계했지만 변수에도 영향이 간 것으로 보인다. 생각해보면, 함수를 호출하기 위한 필수 사전조건은 함수가 정의되어 있어야한다 (=선언되어 있어야 한다.) 프로그램 내부에서 수많은 함수들이 호출될텐데, 각 함수들의 선언 순서를 모두 기억하고 순서에 따라 함수 호출을 제어한다는 것은 불가능하다. 그래서 개발자가 함수의 호출 순서에 구애받지 않고 개발하려면 모든 함수를 사전에 알고 있으면 좋지 않을까 하는 생각에서 이러한 설계가 나오지 않았을까 싶다.정리 호이스팅 과정이 발생하는 이유는 자바스크립트 엔진이 그런 방식으로 설계되었기 때문이고, 자바스크립트 엔진이 그렇게 설계된 이유에는 함수를 편리하게 사용하게 할 목적이었다고 한다. 처음엔 함수 사용 목적이었으나 var 키워드를 통한 변수 선언에도 영향을 받게 되었다. 이러한 var의 한계점을 보완한 변수 선언 방식인 let 키워드가 등장했다." }, { "title": "왜 원시형 데이터는 스택에, 참조형 데이터는 힙에 저장할까?", "url": "/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%8B%A4%ED%96%89%EA%B3%BC-%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%95%A0%EB%8B%B9/", "categories": "프로그래밍", "tags": "메모리 할당, 스택, 힙, 메모리, OS", "date": "2023-01-24 00:00:00 +0900", "snippet": "Intro 원시형 데이터는 스택에, 참조형 데이터는 힙에 저장된다.스택은 힙보다 빠르고, 작다.대부분의 언어에서 일반적으로 이런 방식으로 데이터를 할당한다. 한 단계 더 깊이 생각해보면, 스택과 힙에 대해서 궁금한 점들이 생긴다. 정말 모든 원시형 데이터는 모조리 다 스택에, 모든 참조형 데이터는 모조리 다 힙에 저장되는 걸까? 참조형 데이터인 객체도 내부 속성으로 원시형 데이터를 갖고 있는데 그럼 이 내부 속성의 원시형 데이터는 스택/힙 중에 어디에 저장되는 걸까? 여기서 말하는 스택이 콜스택을 말하는 건가? 왜 스택은 힙보다 빠르고, 용량이 더 적을까? 근본적으로 왜 다른 메모리 공간에 각각 데이터를 저장하도록 되어있을까?데이터 타입에 따라 메모리 어디에 할당되는지 좀 더 명확하게 알고자 내용을 정리해보았다.Stack, Heap 데이터가 저장되는 두 가지 공간우선 내가 짠 프로그램이 실행될 때, 실행 중에 생기는 모든 데이터는 스택과 힙이라는 메모리 공간에 저장된다. 이 스택과 힙 메모리는 어떻게 근본적으로 다르며, 그렇기 때문에 파생되는 현상들은 무엇들이 있는지 확인해볼 필요가 있다. 여기서는 자료구조로서의 스택과 힙 보다는, 메모리서의 스택과 힙을 의미한다.스택과 힙에 대한 공통점 먼저 언급하자면, 스택과 힙은 모두 물리적으로 같은 메모리이다. 램의 한 구역으로 존재한다. 스택 mbti = 극J, 힙 mbti = 극P1. Stack무언가를 알아볼 땐, 단어의 정의를 먼저 확인해주는 것이 인지상정. stack의 사전적 정의는 뭘까 사전에서 찾아보았다. [noun] a pile of objects, tpically one that is neatly arranged.순서대로 정리된 객체들의 묶음이다. (neatly = orderly) 스택은 순서가 있고, 이 순서의 기준은 후입선출(LIFO)이다. 후입선출에 따라 데이터가 입력되고 삭제된다.(할당되고 해제된다.) 뚫린 입구가 하나인 긴 박스 안에 책들이 차곡차곡 쌓여있는 이미지를 떠올리면 된다. mbti로 보면 극 이런 구조로 인해 다음과 같은 특징들이 생겨난다. 데이터가 연속적으로 위치해있다. 한 방향이다. 접근할 수 있는 데이터는 가장 최상위 데이터 밖에 없다. 모든 데이터에 마음대로 접근할 수 없다. 흐름을 관리할 수 있다. 데이터가 쌓이는 순서를 추적할 수 있다.그렇기 때문에 프로그램의 실행 흐름을 관리하기에(=저장하기에) 적합하다.A함수 -&amp;gt; B 함수 -&amp;gt; B 함수 리턴과 종료 -&amp;gt; 다시 A로 돌아와서 C함수 -&amp;gt; ....함수의 호출 순서대로 스택에 넣고 빠지게 되고 가장 최근에 호출된, 실행중인 함수에만 접근할 수 있다. 함수가 리턴과 함께 종료되면 스택에서 꺼내어 해제한다. 이렇게 하나씩 최상위 함수들을 꺼내다보면 결국엔 이 순서가 전체 프로그램의 실행 순서를 의미하게 된다. 따라서 스택 메모리에는 프로그램의 실행과 관련된 데이터들이 저장된다. 스택을 콜스택으로 부르기도 한다.스택에는 실행과 관련된 정보들이 저장된다는 얘기는 각 실행의 주체마다 스택을 하나씩 갖고 있다는 뜻이기도 하다. 또한 이는 스택에 접근할 수 있는 주체가 오직 하나라는 뜻이기도 하다. 실행을 호출하고 관리하는 주체만이 해당 스택에 접근할 수 있다.*(스택이 Thread safe 하다는 의미는 다른 실행 주체의 스택에 접근할 수 없기에 다른 주체로부터의 데이터 변경이 일어날 수 없어 안전하다는 말이다.) 따라서 스택은 private하다. 스택의 자원을 오직 한 주체만 접근할 수 있다.스택이 프로그램의 실행과 관련된 정보들을 다루고 있다보니 스택은 OS가 관여하게 된다. OS가 스택의 사이즈를 결정하고, 스택에 저장되는 데이터의 입출력도 담당한다는 얘기다. 스택이 OS에 관리됨으로써 생기는 파생 현상들은 무엇들이 있을까? 스택은 힙보다 작다.왜 스택은 비교적 적은 용량을 가지는 걸까. 스택의 크기를 결정하는 OS 입장에서 생각해보자. OS는 극강의 가성비를 원한다. 무언가 낭비되는 꼴을 못 본다. OS가 내리는 모든 결정들의 판단 기준은 다음과 같다. 가능하면 적은 메모리를 할당하고 싶어한다. 사용되지 않는 메모리는 최소화되어야 한다. 예측가능한 것을 좋아한다. 예측이 가능해야 딱 그만큼의 메모리만 할당할 수 있으니까.따라서 OS는 가능한 적은 공간을 스택으로 할당하고 싶어하고, 그 공간에는 예측가능한 데이터들을 저장하고 싶어할 것이다. 그래서 이미 크기가 정해져 있는 원시형 타입들이 스택에 저장된다고 하는 것이다. 여기에 추가로 함수 실행과 관련된 데이터들이 저장된다. 함수 내에서 선언되는 변수 (참조형 데이터의 경우 힙에 저장된 참조형 데이터의 주소값이 스택에 저장된다.) 함수 파라미터 해당 함수가 호출된 환경에 대한 정보또한, 쓰레드당 하나의 스택이 배정되기 때문에 한정된 메모리 자원상, 스택의 크기가 커지게 되면 상대적으로 더 적은 쓰레드를 생성할 수 밖에 없다. 스택은 힙보다 빠르다.스택은 OS가 관여하기 때문에 cpu cache에 저장되는 경우가 있을 수 있고 실제로 많다고 한다. (그래서 적은 용량을 갖게 되는 이유이기도 한다.)오직 ram에만 저장되는 힙에 비해 cpu/ram 모두에 저장될 수 있는 스택이 상대적으로 빠른 것은 당연하다. (물리적 메모리 차이)2. Heap그럼, heap의 사전적 정의는 뭘까. [noun] a disorderly collection of objects placed haphazardly on top of each other.힙의 사전적 정의는 뚜렷한 기준 없이 무작위로 놓여진 것들의 집합이다. (haphazardly = lack of obvious principle of organization.) 트리 형태의 자료구조로서의 힙이 아니라 그냥 여기 저기 무작위로 데이터들이 산발적으로 저장되어 있는 그림을 떠올리면 된다. 엄청 큰 책장에 책이 아무 순서 없이 그냥 집히는 대로 꽂혀진 걸 생각하면 된다. 스택은 순서라도 있었지, 힙은 그런거 없다. mbti로 보면 극P형 인간이다.힙은 public하다. 공공재다. 스택은 실행 주체만 접근할 수 있었던 반면, 힙은 모든 실행 주체들이 접근할 수 있다. 그래서 원시형이지만 전역변수로 선언된 데이터들도 힙에 저장된다. 어떤 실행 주체도 접근할 수 있어야 하기 때문이다. 스택에 저장하면 해당 스택을 가지고 있는 쓰레드만 접근할 수 있기 때문에 전역변수를 저장하기에는 적합하지 않다. 그렇기 때문에 힙은 스택에 비해서 느리다. 여러 주체들이 동시에 접근해야하니까.그리고 힙의 크기는 스택에 비해 크다. 힙에는 참조형 데이터가 저장된다. 클래스, 배열, 함수 등이 저장된다. 컴파일시에는 크기를 알 수 없는 데이터들이 저장된다. 런타임시에 크기가 유동적으로 변하는 데이터들이라고 볼 수 있다. 그래서 충분한 크기가 필요하다. 힙에 저장된 참조형 데이터를 스택에 저장된 변수에서 참조한다. 또한, 힙은 OS가 관여하지 않는다. 그래서 오직 RAM에만 저장되기 때문에 읽고 쓰는데 cpu cache에도 저장되는 스택과는 비교적 느리다.힙은 GC의 대상이된다. GC가 주기적으로 힙을 탐색하면서 해제할 영역들을 찾고 메모리를 해제한다. 스택은 OS 영역으로 GC의 대상이 아니다.여기까지가 스택과 메모리에 대한 비교/차이점 및 그로 인한 메모리 할당 과정 특징들을 모아보았다. 아래는 스택과 힙 메모리에 대한 일반적인 차이점을 쉽고 명확하게 정리한 영상이다. Stack vs Heap Memory - Simple Explanation궁금증 해결앞서 Intro에서 언급했던 질문들이 답을 해보자면, 정말 모든 원시형 데이터는 모조리 다 스택에, 모든 참조형 데이터는 모조리 다 힙에 저장되는 걸까? 아니다. 데이터 타입 + 선언 시점으로 결정된다. 원시형/참조형 데이터 타입에 따라 무조건적으로 칼 같이 스택/힙에 저장되는 건 아니다. 데이터 타입 + 선언 시점도 중요한 기준이 된다. 지역변수인지/ 전역 변수인지에 따라 다른 메모리 영역이 필요하기 때문이다. 원시형이더라도 전역변수로 사용되야 하거나, 인스턴스 내의 속성으로 사용된다면 스택이 아니라 힙에 저장되어야 한다. 참조형 데이터인 객체도 내부 속성으로 원시형 데이터를 갖고 있는데 그럼 이 내부 속성의 원시형 데이터는 스택/힙 중에 어디에 저장되는 걸까? 참조형 데이터 내의 원시형 데이터는 힙에 저장된다. 여기서 말하는 스택이 콜스택을 말하는 건가? 맞다. 스택은 실행 주체마다 하나만 존재한다. 그 스택이 실행 흐름을 관리하기 때문에 콜스택이라고 부른다. 왜 스택은 힙보다 빠르고, 용량이 더 적을까? 프로그램 실행 흐름 관리에 필요한 데이터(1)와 실행 중에 생기는 데이터(2)는 다른 특성을 갖고 있기 때문. (1)은 순서를 관리해야하고, (2)는 크기가 유동적으로 변한다는 특징. 프로그램 실행 흐름을 OS가 관리하기 때문에 파생되는 물리적 메모리의 성능 차이. 근본적으로 왜 다른 메모리 공간에 각각 데이터를 저장하도록 되어있을까? 메모리를 두 가지 공간으로 분리하여 각 특성에 맞게 따로 저장하는 것이 더 효율적이기 때문이다. 정리(스택오버플로우) 객체 내의 원시 데이터는 어떻게 저장되나요?이 게시글이 궁금증의 출발이었다. 자바스크립트를 공부하다보면 원시형은 스택에, 참조형은 힙에 저장된다고 하는데, 결국엔 참조형도 원시형을 포함하고 있는데 그럼 참조형 데이터들은 도대체 어디에 저장된다는 걸까 궁금했다. 찾아보다보니 결국엔 스택과 힙 메모리의 근본적인 차이와 프로그램이 실행되면서 어떤 데이터들이 필요하고 어떤 특성을 가지고 있어서 분리되어 저장되는지에 대한 문제였다.이 게시글에 달린 답변이 인상적이다. ECMA 스펙을 보면 메모리 관리에 대해서 아주 조금 언급할 뿐이다. 힙이나 스택에 대해서 구체적으로 명시하고 있지 않다. 많은 프로그래밍 언어들도 메모리 관리에 대해서 그 어떤 것도 구체적으로 제한하고 있지 않다. 개발자가 프로그램을 만드는데 필요한 만큼의 정도의 제한사항만 얘기하고 있을 뿐이다. 이는 메모리 관리로부터 개발자를 자유롭게 한다. 메모리 관리를 신경쓰지 않고 자유롭게 개발하면 되는 것이다. 이 질문에 대한 답은 모르고, 알 수도 없고, 알아서도 안된다. 모든 해당 언어를 가지고 구현하는 사람들은 메모리 관리로부터 자유로워야 한다.= 이분법적으로 절대적인 기준이 있어서 그 기준에 따라 메모리가 할당되는 것이 아니다. 이건 OS의 영역이지, 개발자의 영역이 아니다. 그렇기 때문에 내부적으로 OS가 실제로 어떻게 메모리를 할당/관리하는지 개발자는 몰라도 되고, 실제로 까볼 수도 없으므로 몰라야 하는 것이 정상이고 알 수도 없다.맞는 말인 것 같다. 지금까지 개발하면서 메모리 관련 에러를 만난 적이 없었다. 그래도 스택/힙과 관련된 개념들 밑에 있는 과정들이 궁금했었다." }, { "title": "프로그래머스 | 옹알이 - Javascript 문제풀이", "url": "/posts/ps-%EC%98%B9%EC%95%8C%EC%9D%B4-JS/", "categories": "알고리즘", "tags": "알고리즘, JS, Problem Solving, 프로그래머스", "date": "2023-01-23 00:00:00 +0900", "snippet": "문제프로그래머스 - 옹알이(1)머쓱이의 조카는 문제에서 정의한 4개의 단어만 이어 붙여서 말할 수 있다. 단어들이 주어졌을 때 머쓱이의 조카가 말할 수 있는 단어의 개수를 맞추는 문제이다.풀이 과정 babbling에는 보기 단어들이 주어진다. 이 단어들을 순회하면서 머쓱이가 말할 수 있는 단어를 포함하고 있다면 이를 다른 문자로 갈아끼우면서 이어 붙여서 말할 수 있는지 검사해 나간다. babbling 반복문 안에 머쓱이가 말할 수 있는 단어들의 반복문이 중첩된 구조이다. 여기서 핵심은 이어 붙여서 말하는 것이므로, 빈 문자열로 대체하게 된다면 이상한 경우가 발생한다. 예를 들어 wyeoo 의 경우, ye가 지워진 woo 가 되고 또 woo 가 지워저 결국 최종적으로 빈 문자열이 남아서. 머쓱이 조카가 말할 수 있는 단어로 이루어진 문자가 되어 answer에 카운팅되게 된다. 제한조건은 단어를 이어 붙여서 말하는 것이므로 woo 사이에 ye가 끼워진 wyeoo는 정답에 포함되어서는 안된다. 이를 바로잡기 위해서는 빈 문자가 아니라 다른 문자로 바꿔야 한다. 만약 언더바로 바꾼다고 하면 wyeoo -&amp;gt; w_oo 이렇게 되어 woo가 포함되는 것을 막을 수 있다. 말할 수 있는 단어가 포함되어 있다면 해당 단어를 _로 바꾸어 나가다가 모든 반복문이 종료되었을 때 남게되는 최종 문자열이 모두 _로 이루어져 있다면 이는 정답에 포함시킨다.풀이 코드function solution(babbling) { let answer = 0; const speek = [&#39;aya&#39;, &#39;ye&#39;, &#39;woo&#39;, &#39;ma&#39;] for(let babble of babbling) { for (let word of speek) { babble = babble.replace(word, &#39;_&#39;) if (&#39;_&#39;.repeat(babble.length) === babble) { // babble이 &#39;_&#39;으로만 이루어져 있는지 검사하는 조건 answer++ break } } } return answer;}정리 String.prototype.replace, String.prototype.repeat 등과 같은 문자열 메소드에 대해서 문서를 다시 읽어보며 정리하게 되었다. 자바스크립트로 풀어본 첫 문제였다. 호호. 자바스크립트 배열, 문자열 메소드를 많이 알고 있어야 되겠다." }, { "title": "JS에서 안전하게 널값 처리하기 Optional chaining(?.) &amp; Nullish coalescing operator (??)", "url": "/posts/JS-optional-chaining-&-nullish-coalescing-operator/", "categories": "JS", "tags": "JS, Javascript, Nullish", "date": "2023-01-13 00:00:00 +0900", "snippet": "JS에서 널값 안전하게 유연하게 처리하기 Uncaught TypeError: Cannot read properties of undefined (reading ‘xxx’) 위의 에러는 undefined인 객체의 xxx 속성에 접근하려고 할 때 쉽게 만날 수 있는 에러이다. 이런 에러를 만나게 되면 대부분 이전 단계에서 조건문을 통해 undefined인지 체크를 하고 undefined 가 아님을 보장한 상태에서 내부의 속성값을 접근하도록 해주었다. 그러나 ?., ?? 연산자를 사용하면 내가 직접 체크를할 필요 없이 좀 더 편하고 유연하게 처리할 수 있다.얼마 전에 프로젝트 소스코드를 보다가 처음 보는 자바스크립트 코드를 보게되었다. 삼항연산자 같기도 하고, .을 이어 붙여서 속성에 접근하는 것 같기도 하고.return xxxList?.ooProperty?.xxProperty ?? defaultValue찾아보니 ?.연산자는 Optional Chaining, ?? 연산자는 Nullish coalescing operator 라고 한다. ES2020 표준으로 나름 최신 문법이다.이 두 가지 연산자는 모두 객체의 널값과 관련이 있다. 접근하고자 하는 값이 nullish한 경우 undefined 에러를 뱉지 않고 분기처리할 수 있도록 도와준다. 따라서 해당 속성값을 참조하기 이전에 조건문 등으로 해당 값이 존재하는지 여부를 판단하는 코드를 추가할 필요 없이 속성에 접근하는 연산자만 사용하면 된다.Optional Chaining &amp;lt; ?. &amp;gt;직독직해하면 선택적 체이닝. 선택적의 대상은 접근하고자하는 값이 nullish한지 여부다. ( nullish = null 또는 undefined.)nullish 여부에 따라 체이닝을 이어나가기도, 멈추기도할 수 있다.문법은 . 접근 연산자 앞에 ? 을 붙이면된다. ?. 연산자를 적용할 수 있는 대상은 객체의 속성값, 표현식, 함수호출 3가지이다.obj.val?.propobj.val?.[expr]obj.func?.(args)? 앞의 속성에 대해서 nullish 여부를 체크한다. (즉, obj.val에 대해서) nullish 하지 않다면 체이닝을 이어나간다. nullish 하다면 undefined를 리턴하고 체이닝을 이어가지 않고 종료한다.let car = { power: 240, engine: { aaa: 100, bbb: 200, ccc: { ... } }}car.engine.ddd.prop // #1. Uncaught TypeError: Cannot read properties of undefined (reading &#39;prop&#39;) car.engine.ddd?.prop // #2. return undefined그리고 무엇보다도 nullish한 경우 type error를 내뱉지 않고 널값 처리를 할 수 있어 안전하게 널값을 처리할 수 있다는 장점이 있다. ddd 속성이 nullish 하기 때문에 prop에 접근할 수 없어서 TypeError ddd?. 옵셔널 체이닝 연산자를 이용하여 ddd가 nullish인지 체크하고 undefined 반환하고 에러 없이 종료.?가 붙어있는 속성값에 대해서만 체크를 하기 때문에,car.engine?.ddd.prop 으로 접근해도 #1과 같은 에러가 난다. 따라서 ?을 잘 붙여서 사용해야 한다.코드를 작성하는 사람은 데이터 구조를 알고 있기 때문에 당연히 값이 있다고 생각하고 또는 그럴거라고 짐작하고 . 연산자로 이어붙여 해당 값에 접근하게 된다. 막상 런타임에서 수많은 값의 변경이 연쇄적으로, 동시다발적으로 일어나게 되면 어느 순간은 null 이나 undefined로 참조되는 경우가 많다. 그렇게 되면 내가 작성한 코드는 TypeError를 내뿜게 되는 것이다.보통 중첩된 정도가 깊지 않은 경우에는 앞서 해당 속성값이 존재하는지 여부를 조건문을 통해 별도로 체크해주게 된다. 그러나 optional chaining 연산자는 별도로 체크해주는 과정을 대신 해준다.(실전 적용) Vue 컴포넌트에서 사용해보기뷰 컴포넌트의 template 코드 안에서도 이 문법이 적용될까?사실 이 부분이 제일 궁금했다. 중첩된 객체를 특정 컴포넌트의 props로 넘겨주는 경우가 그렇다.&amp;lt;template&amp;gt; &amp;lt;MyComponent :data=&quot;myData.files.itemList&quot;&amp;gt; &amp;lt;/MyComponent&amp;gt;&amp;lt;/template&amp;gt;위의 코드에서 만약 files가 undefined라면 콘솔에 TypeError가 날 것이다. (실제로 개발하면서 엄청 많이 겪었다.) 이런 경우에 대비해서 나는 주로 v-if / v-show 디렉티브를 사용했다. 중첩된 속성 접근 전에 항상 이런 방어적인 코드를 추가하다보니 번거롭다는 생각을 하기도 했고, 실수로 누락되는 부분이 생기기 마련이었다. 그래서 옵셔널 체이닝 문법을 사용하면 사전의 v-if / v-show 를 쓰지 않아도 될 것 같아서 실험을 해보았는데 아직 template 내에서 옵셔널 체이닝 문법을 사용하지는 못한다. 물론 vue2 기준이다.&amp;lt;template&amp;gt; &amp;lt;MyComponent :data=&quot;myData.files?.itemList&quot;&amp;gt; // error 뷰가 이해하지 못한다. &amp;lt;/MyComponent&amp;gt;&amp;lt;/template&amp;gt;물론, script 태그 내에서는 옵셔널 체이닝 문법 사용이 가능하다.Nullish coalescing operator &amp;lt; ?? &amp;gt;return xxxList?.ooProperty?.xxProperty ?? defaultValue아까 위에 코드를 다시 보면, ?? 연산자도 보인다. 딱봐도 삼항연산자 비스무리하게 생겨서 짐작하기 쉬웠다.//문법leftExpr ?? rightExpr//예시 const aaa = 0 ?? &#39;default value&#39; // &#39;default value&#39;const bbb = isEmpty() ?? false?? 연산자는 논리 연산자다. ?? 기준으로 앞선 왼쪽 논리식이 null 또는 undefined 라면 오른쪽 값을 반환하고 true하다면 왼쪽 값을 반환하는 연산자이다. 여기서 true로 판단하는 기준은 해당 값이 falsy한지 여부다. (false, ‘’, “”, 0, NaN 모두 falsy한 값이므로 true가 된다.)MDN 문서에서는 OR 논리 연산자의 특별한 케이스라고 설명하고 있다. ?? 와 || 연산자의 차이점은 false 판단 기준이다.거짓 판단 기준?? 오직 null, undefined 값만 false로 판단한다. 빈 문자열, 0, NaN도 값으로 인정하여 true로 판단한다.|| null, undefined, ‘’, “”, 0, Nan 등 자바스크립트에서 falsy 하다고 여겨지는 것들을 모두 false로 처리한다.빈 문자열, 0 도 자바스크립트 엔진이 거짓값스럽다?라고 해석하는 걸 볼 수 있다. 이걸 영어로 falsy 하다고 한다. 나도 이번에 처음 알았다. 실제로 코드로 실험해보면 다른 결과가 나오는 걸 볼 수 있다.숫자 0 0 ?? &#39;default value&#39; // return 00 || &#39;default value&#39; //return &#39;default value&#39;빈 문자열&#39;&#39; ?? &#39;default value&#39; // return &#39;&#39;&#39;&#39; || &#39;default value&#39; // return &#39;default value&#39;falsy한 값들도 고유한 값으로 인정하여 true하도록 하고 싶다면 ?? 연산자를 사용하면 된다. 주로 변수의 디폴트 값을 할당할 때 ??, || 연산자를 많이 사용하게 될텐데 변수에 의미를 주고 싶을 때에 따라 적절하게 같이 사용하면 될 것 같다.또한 다른 논리 연산자들처럼 왼쪽식이 false이면 오른쪽 식은 검증하지 않는다.안전하게 객체 속성에 접근하기MDN 문서에서는 ?. 연산자와 ?? 연산자를 같이 사용하여 안전하게 속성값에 접근할 것을 권장하고 있다. 여기서 안전하게라는 말은 nullish한 객체의 속성을 접근하고자 하는 시도일 것이다.foo = { first : { prop: 100}}foo.first?.prop ?? &#39;default value&#39;?. 연산자로 값을 연속해서 접근해나가다 최종 접근 속성값이 undefined 또는 null 이라면 ?? 연산자 뒤의 값을 할당하는 방식으로 가장 많이 조합되어 쓰일 것 같다.참고 Nullish 하다는 것 = 값이 Null 또는 undefined falsy 하다 = 논리식에서 false로 판단되는 값들 false, 0, -0, ``, ‘’, “”, NaN, Null, undefined MDN 문서 optioncal chaining MDN 문서 nullish coalescing operator" }, { "title": "코어 자바스크립트 | 1. 데이터의 가변성과 불변성", "url": "/posts/TID/", "categories": "코어 자바스크립트", "tags": "Javascript, 개발 서적", "date": "2022-09-13 00:00:00 +0900", "snippet": "0. 자바스크립트의 데이터 유형JS의 데이터 유형은 2 가지가 있다. primitive (=원시형, 기본형) number, string, boolean, null, undefined reference (=참조형, 객체형) object, array, function … 왜 이렇게 두 분류로 나눈걸까. 결론부터 말하자면 데이터가 저장되는 메모리 영역의 특징 때문이다. + (여러 속성으로 이루어진 하나의) 객체를 저장하기 위함…? 자바스크립트 메모리 영역은 변수 영역 : 변수의 식별자가 저장된다. 데이터 영역 : 변수가 저장된다.으로 나누어진다.데이터 메모리 영역은 한 번 할당되면 재할당이 불가능하다. GC가 수거해 가기전까지는…반면 변수 영역은 한 번 할당한 영역에 재할당이 가능하다.따라서 원시형과 참조형은 불변성과 가변성 측면에서 차이점이 있다.사실, 내부적으로 보면 원시형과 참조형 변수에는 모두 어떤 주소값이 저장되어 있다. 그 주소값이 바로 데이터 영역이냐 변수 영역이냐가 원시형/참조형을 구분하게 된다.그럼 자바스크립트가 원시형/참조형 데이터들을 어떻게 메모리에 할당하고 접근하는지 보자보자보자.1. 자바스크립트의 데이터 할당var name = &#39;jane&#39;name = name + &#39;doe&#39;name이라는 원시형 변수를 선언과 동시에 ‘jane’으로 할당하는 코드다. 이를 자바스크립트의 메모리 관점에서 본다면, 아래와 같다.name이라는 변수는 ‘jane’이라는 문자열이 저장된 메모리 주소의 주소값을 가지고 있다. 그리고 name변수에 ‘doe’문자열을 이어붙여서 name에 새로 할당한다. 이를 메모리 관점에서 보면, 기존의 100 주소에 있던 데이터(‘jane’)가 새로운 이어붙인 데이터(‘jane doe’)로 바뀌는 것이 아니라, 새로운 데이터 영역을 할당받고 그 주소값으로 변경된다. 원시형 타입이 불변하다고 하는 이유가 여기 있다. 한 번 할당된 데이터 영역의 데이터는 GC가 수거해가지 않는 이상 바뀌지 않는다. 새로운 데이터가 생기고 할당될 뿐이다.그렇다면 참조형 데이터의 데이터 할당은 어떨까.var person = { age: 25, gender: &#39;female&#39;} 참조형은 각 객체마다 별도의 변수 영역을 갖는다는 것이 특징이다. 각 속성의 값은 같은 데이터 영역을 사용한다. person 변수에는 해당 객체의 속성들을 가리키고 있는 주소값(100)이 할당된다. 데이터 영역의 100번지 주소는 person 객체의 속성의 주소값을 데이터값으로 가지고 있다.결과적으로 변수가 변수에 저장된 값에 도달하기까지 원시형 변수는 다리가 1 개, 참조형 변수는 다리가 2개 놓여져 있다고 비유할 수 있다. 원시형 변수는 변수에 저장된 주소 값으로 가면 바로 데이터가 있지만 ( 1단계 ) 참조형 변수는 변수에 저장된 주소 값으로 가면 ( 1단계 ) 바로 객체의 속성들의 데이터 값이 있는 것이 아니라, 또 다른 주소값이 저장되어 있고, 그 주소값으로 가면 ( 2단계 ) 비로소 객체의 속성들의 값을 가리키는 주소값이 저장되어 있다.중요한 것은..**원시형/참조형 변수의 불변성/가변성의 대상은 메모리 영역이다!! ** 변수 영역의 불변/가변을 따지는 것은 참조값이 바뀌느냐 아니는냐로 볼 수 있는데, 이렇게 되면, 원시형은 데이터가 바뀔 때마다 새로운 영역의 주소값이 할당되기 때문에 변수 영역이 매 번 바뀐다는 점에서 가변이 되고, 참조형은 아무리 속성값이 바뀐다고 해도 변수 영역의 주소값 자체가 바뀌는 것이 아니기 때문에 불변이라고 볼 수 있다. 아예 새로운 객체를 만들고 할당해버리면 또 가변이라고 볼 수 있긴 하다.2. 자바스크립트의 데이터의 복사데이터를 할당 했으니 복사를 해보자보자.var a = 100var b = a a = 123console.log(b) // 100원시형의 할당 변수 영역에 식별자 a를 할당한다. 데이터 영역에 100을 할당한다. (주소 : @101) 변수 a = @101 변수 영역에 식별자 b를 할당한다. 변수 b = @101 (a에 저장된 주소값)원시형의 데이터 갱신 데이터 영역에 123을 새롭게 할당한다 (주소 : @202) 변수 a = @202 이 시점에서 a와 b는 서로 다른 주소값을 가리키게 된다. ( = 연결이 끊어짐)-&amp;gt; 변경/재할당이 안 되는 데이터 영역의 특성상 데이터 갱신이 일어날 때마다 새로운 주소값이 변수 영역에 할당되게 되면서 결과적으로는 원시형의 복사는 값의 복사가 된다. ( = 둘 중 어느 하나가 변경되도 서로에게 영향을 미치지 않음.)var obj = { a : 100, b : 200}var copy = obj copy.a = 111console.log(obj.a) // 111참조형의 할당 변수 영역에 obj가 할당된다. 객체의 변수 영역에 a와 b가 할당되고, 데이터 영역에 100과 200이 할당되고 각 주소값이 객체의 변수 영역의 a와 b에 저장된다. obj는 객체의 변수 영역을 가리키는 주소값이 저장된 데이터 영역의 주소값이 저장된다. (말이 너무 어렵네…) obj에는 값이 아니라 참조값이 저장되어 있다.참조형의 복사 변수 영역에 copy가 할당된다. obj에 저장된 주소값이 copy에 저장된다. 객체의 a 속상값이 바뀐다. 새로운 데이터 영역이 할당되고 (111) 객체의 변수 영역의 a 값이 새로운 데이터 영역의 주소값으로 바뀐다. 내부의 값이 바뀌었을 뿐, a와 b의 저장된 주소값이 변경된 것은 아니다 ( 원시형과 다른 부분) 두 식별자가 모두 같은 주소값을 바라보고 있다는 것은 둘 중 어느 하나가 변경되도 모두 에게 영향을 미친다는 의미로 볼 수 있다.원시형/참조형의 복사 결과가 달라지는 이유는 역시 데이터 할당 때문이다.3. 정리 원시형/참조형 식별자 모두 어떤 주소값이 저장되어 있다. 그 주소값이 데이터 영역의 주소를 가리키면, 매번 새로운 주소값으로 바뀌게 된다. ( = 데이터 영역은 불변하므로 갱신때마다 새로운 데이터 영역이 할당되고 새로운 주소값이 생기게 됨) -&amp;gt; 원시형 그 주소값이 변수 영역의 주소를 가리키면, 내부 속성들의 주속값만 바뀔 뿐, 식별자에 저장된 주소값이 바뀌는 것은 아니다. -&amp;gt; 참조형4. 느낀점primitive, reference두 단어의 의미를 생각해보니 이보다 더 적합한 단어가 있을까 싶었다. 원시형, 즉 원자성을 띄기 때문에 원본 데이터에 바로 참조하는 데이터. 참조형, 원본 데이터에 바로 접근하는 것이 아니라 중간의 무언가를 통해 한 단계 거쳐서 참조하는 데이터.메모리 관점에서 코드를 바라보면 평소에 당연하게 생각했던 것들도 갑자기 낯설어진다." }, { "title": "Dockerfile | RUN, CMD, ENTRYPOINT 명령어 차이점", "url": "/posts/Dockerfile-RUN,-CMD,-ENTRYPOINT-%EC%B0%A8%EC%9D%B4%EC%A0%90/", "categories": "docker", "tags": "docker, devops", "date": "2022-08-14 00:00:00 +0900", "snippet": "Dockerfile 명령어 속성 RUN CMD ENTRYPOINT도커파일을 작성할 때 명령어를 지시할 수 있는 3가지 속성이 있다. 3가지의 실행 시점과 차이점을 잘 알아야 도커파일을 잘 사용할 수 있다. (나처럼 삽질 안 하고…)0. IntroFROM node:16-alpine as builderWORKDIR /appCOPY package.json .COPY yarn.lock .RUN yarnCOPY . .EXPOSE 8080CMD [ &quot;yarn&quot;, &quot;build&quot; ]FROM nginx:stable-alpine as productionRUN rm -rf /usr/share/nginx/html/*COPY --from=builder /app/dist /usr/share/nginx/htmlEXPOSE 80 CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;] Q. 이 도커파일에서 틀린 곳을 찾아보시오. A. ???1. 내가 의도한 도커파일은 yarn으로 의존성들을 설치하고 이를 /app/dist 폴더 밑에 빌드한다. 빌드된 산출물들을 nginx로 서빙하기 위해 하위 파일들을 복사 붙여넣기 한다. nginx 실행으로 아주 간단한 nodejs 앱 기반의 빌드 - 배포 시나리오이다. 기존에는 프론트 앱의 publicPath = ~/repository_name/ 이렇게 설정을 한 상태였다. 굳이 그럴 필요가 없을 것 같아서 해당 설정을 지우고 (vue.config.js파일) 다시 동일한 도커 파일을 이용해 도커 이미지를 빌드해주었다. 빌드한 이미지를 실행하고 해당 url을 확인해보니 여전히 default로 모든 요청 파일에 ~/repository_name/이 붙어 있었다. 즉, 수정 사항이 반영 안 되었다는 얘기다.정확한 에러는 다음과 같다.&amp;lt;noscript&amp;gt; &amp;lt;strong&amp;gt;We&#39;re sorry but #myappname@ doesn&#39;t work properly without JavaScript enabled. Please enable it to continue.&amp;lt;/strong&amp;gt;&amp;lt;/noscript&amp;gt;빌드가 정상적으로 되었으나, default 호출 url로 prefix에 ~/repository_name/이 붙어서 나는 안내 메세지였다. 즉 호출을 잘못하고 있다는 뜻이다.이를 해결하기 위해 해본 삽질 publicPath 설정 바꿔줌 : 효과 x vue 인스턴스를 초기화하는 방식 변경 : 효과 x 콘솔에 나오는 경고 메세지 관련한 코드 찾아서 수정 : 효과 x 포트 변경 : 효과 x nginx의 html 하위 파일 모두 삭제 후 다시 도커 빌드 : 효과 x사실 핵심은 첫번째인데. publicPath 설정을 바꿔준 수정 사항이 당최 도커 이미지에 반영이 안되는 것으로 생각하고 도커파일 관련해서 다시 찾아보던 중….CMD는 도커 파일 내에서 한 번만 실행된다는 것을 알았다. 중복해서 쓰였을 경우 가장 마지막이 실제로 호출된다는 것이었다.저 위에 도커 파일에서 잘못된 점은CMD [ &quot;yarn&quot;, &quot;build&quot; ]CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]이 부분으로 CMD를 두 번 작성하여 아래의 CMD문이 반영된 것이다. 즉 코드를 백만번 수정해도 실제로는 빌드를 하지 않은 셈이다. 그래서 반영이 안되었던 것이다.2. 차이점RUN과 CMD 모두 명령어겠지~ 라고 생각하고 두 개의 차이점을 인지하지 못하고 작성했던 것이 문제였다. 찾아보니 관련된 속성으로 ENTRYPOINT라는 녀석까지 하나 더 있다고 한다.핵심은 3가지 구문 모두 실행시점이 각자 다르다는 것!RUN 실행시점 : docker image가 빌드되는 동안도커 엔진이 도커 파일을 한 줄 한 줄 읽으면서 이미지를 빌드할 때 실행된다.CMD 실행시점 : 빌드가 완료되고 해당 이미지가 실행될 때 (시작)빌드되는 동안에 실행되는 것이 아니라, 실제로 이미지가 실행되기 시작할때 CMD 구문이 실행된다. 그리고 docker run 명령에 인자값으로 넘겨서 사용할 수도 있다.docker run {image} {cmd_command}이런 경우에는 이미 dockerfile에 정의된 cmd 구문은 실행되지 않고 docker run에 인자값으로 넘긴 cmd 구문이 실행된다. 도커 공식 문서 중 CMD 관련 부분 Do not confuse RUN with CMD. RUN actually runs a command and commits the result; CMD does not execute anything at build time, but specifies the intended command for the image.=&amp;gt; Run과 CDM를 헷갈리지말 것. Run은 명령구문을 실행하고 결과물을 저장한다. (= 이미지를 빌드한다는 뜻) CMD는 빌드 타임에는 아무것도 실행되지 않는다. 그러나 특정 커맨드를 의도대로 지정할 수 있다. (=동일 이미지에 가변적으로 명령어를 지정할 수 있다는 뜻)ENTRYPOINT 실행시점 : CMD랑 같다그럼 CMD와의 차이점은 docker run으로 CMD의 내용을 상황에 따라 바꿀 수 있는 것과 달리, 항상 실행된다는 점이다. 즉 dockerfile 내에서 정의한 ENTRYPOINT는 해당 컨테이너 실행시에 변경할 수 없다. 도커 공식 문서 중 CMD와 ENTRYPOINT 차이점 부분 도커파일은 최소한 한 개의 CMD 혹은 ENTRYPOINT가 있어야 한다. ENTRYPOINT는 컨테이너를 실행파일로 사용할 때 정의해야 한다. CMD는 ENTRYPOINT의 default 값으로 지정하는 방식으로 사용해야 한다. CMD는 컨테이너를 실행할 때 다시 정의할 수 있다. 3. 요약 이미지가 빌드 되는 동안에는 RUN 이미지가 실행될 때, 가변적으로 실행되어야 할 때는 CMD 이미지가 실행될 때, 항상 똑같이 실행되어야 할 때는 ENTRYPOINT4. 그래서 Q. 이 도커파일에서 틀린 곳을 찾아보시오. A. 답은FROM node:16-alpine as builderWORKDIR /appCOPY package.json .COPY yarn.lock .RUN yarnCOPY . .EXPOSE 8080# CMD [ &quot;yarn&quot;, &quot;build&quot; ] CMD가 아니라, RUN으로 바꿔야 한다.RUN yarn build FROM nginx:stable-alpine as productionRUN rm -rf /usr/share/nginx/html/*COPY --from=builder /app/dist /usr/share/nginx/htmlEXPOSE 80 CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]CMD가 두 번 사용되었기 때문에 빌드가 안 되고 있었던 상황이다.빌드라는 것은 이미지가 실행되기 전에 이미 완료되어야하는 작업이므로 빌드 중일 때 실행되는 명령어인 RUN을 사용하는 것이 맞다.5. Shell form, Exec formrun, cmd, entrypoint 모두 2가지 form을 지원하고 있다. 배열로 전달하는 여부에 따라 달라진다.RUN yarn build // shell form RUN [&quot;yarn&quot;, &quot;build&quot;] // exec form 배열로 사용할 것을 권장하고 있다. 작성한 구문을 도커 엔진이 읽을 때 과정을 한 단계 거치지 않아서 더 깔끔하다는 것…이라고 이해했다.또한 exec form 으로 사용할 시에는 double quote &quot;&quot; 을 사용해야 한다. JSON형식으로 명령어들을 파싱하기 때문이라고 한다.6. 나머지 공부정리하면 도커파일 문법을 잘 몰라서 생긴 문제." }, { "title": "Vue2 | Mixin 개념, 여러 컴포넌트에서 재사용하기", "url": "/posts/Vue2-Mixin-%EC%97%AC%EB%9F%AC-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90%EC%84%9C-%EC%9E%AC%EC%82%AC%EC%9A%A9%ED%95%A0-%EC%86%8D%EC%84%B1%EB%93%A4/", "categories": "Vue2", "tags": "Vue2, 컴포넌트재활용", "date": "2022-08-10 00:00:00 +0900", "snippet": "MixinMixin은 여러 컴포넌트들 사이에서 공통적으로 처리해야할 로직, 데이터등을 정의할 수 있는 속성이다.0. Intro오늘 좀 복잡한 컴포넌트를 개발하면서 여러 컴포넌트 사이에서 공통적으로 사용하는 함수 데이터들을 발견했다.미리 정의된 코드들이 있고 이 코드에대한 특정 색깔을 정의하고 있는 데이터, 함수가 있었고, 이 함수를 3~4개의 컴포넌트에서 각자 사용하고 있었다. 각자 사용하고 있다는 말은 모두 각자 컴포넌트에서 methods 속성에 정의하였다는 뜻이다. 즉, 똑같은 기능을 하는 코드가 반복적으로 여러 군데에서 작성되었다는 것이다. 일단 똑같은 코드 블럭을 여러 곳에 붙여 넣기 하는 것이 불편했고 너무 비효율적이라는 생각이 들었다.이런 공통 로직들을 상위 컴포넌트에 등록해놓건,전역으로 설정해놓고 하위 컴포넌트에서 참조해서 사용하는 방법이 없을까 생각했다.수치를 나타내는 값을 3자리씩 끊어서 (,로 끊는 형식 ex: 35,221) 리턴하는 함수를 여러 컴포넌트에서 사용하고 있는 것을 발견하고 해당 함수가 mixin 폴더에 있다는 것을 알 수 있었다.1. 사용법// mixin/gemsMx.js export default { data() { return { gemsColor: { ruby: &#39;red&#39;, sapphire: &#39;blue&#39;, emerald: &#39;green&#39; } } }, mounted() { this.fetchMyGems() }, methods: { fetchMyGems(){ this.GemsApi.getMyGems() } }}Mixin 객체 정의 Vue 인스턴스를 생성할 때 필요한 option 객체의 속성과 동일하다. data, lifecycle hook, methods, computed 모두 정의할 수 있다. 보석과 관련된 기본 정보들을 가지고 있는 Mixin을 작성해보았다. 보석의 색깔에 대한 정보 (data) 내 보석을 가져오는 함수 (methods) 그 함수를 컴포넌트가 mount되었을 때 호출하는 로직 (mounted) // Mixin 사용하는 컴포넌트 &amp;lt;template&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;import { gemsMx } from &#39;~/mixin/gemsMx.js&#39;export default { name: &#39;GemStore&#39;, mixins: [ gemsMx ], // Mixin 사용 data() { return { isBudgetOver : false, gemsList: [] } }, computed() { }}&amp;lt;/script&amp;gt;Mixin 컴포넌트에서 사용 앞서 정의한 Mixin을 import 하여 재사용한다. Mixin의 정의한 내용들이 자동으로 컴포넌트에 정의된다. (반복되는 코드 작성 부분을 줄일 수 있다.) 컴포넌트는 Mixin의 속성을 overwrite할 수도, merge하여 사용할 수도 있다. merge될 경우 컴포넌트의 속성이 우선되어 적용된다.2. 적용Mixin 파일에 여러 컴포넌트에서 분산되어 반복적으로 작성되었던 코드들을 함수로 선언하였다. 따라서 분산되어 있던 중복 코드들은 모두 삭제해주었고, 정상적으로 이전과 같이 잘 작동했다. 리팩토링을 가볍게 한 셈이다.3. 정리 공통으로 사용할 데이터, 함수들을 mixin 객체에 정의하고, 이것을 사용할 컴포넌트에서 해당 mixin을 등록하여 사용하면 된다. Mixin은 여러 컴포넌트에 영향을 주는만큼 잘 설계해서 정의해야 한다.4. 추가Vue 공식 문서에 보면 재활용이라는 개념에서 Mixin과 HOC를 비교하고 있다." }, { "title": "프로그래머스 이중우선순위큐 문제 풀이", "url": "/posts/pg%EC%9D%B4%EC%A4%91%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84%ED%81%90/", "categories": "알고리즘", "tags": "Problem Solving, 알고리즘, 파이썬", "date": "2022-04-04 00:00:00 +0900", "snippet": "프로그래머스 - 이중우선순위큐문제https://programmers.co.kr/learn/courses/30/lessons/42628두 개의 우선순위큐를 이용하여 최소 최대 상태를 유지한다. Que 1, 최소큐 : 최소값을 얻기 위한 큐 Que 2, 최대큐 : 최대값을 얻기 위한 큐 (음의 부호를 붙여 최댓값을 구할 수 있도록 한다.)두 개의 map을 이용하여 이미 pop한 노드들을 기록한다. Check 1 : 최대큐에서 삭제한 노드를 최소큐에서 중복되어 삭제하지 않도록 기록한다. Check 2 : 최소큐에서 삭제한 노드를 최대큐에서 중복되어 삭제하지 않도록 기록한다.예를 들어, I 2 / I -3 / I -3 / I -3 / D -1 / D -1 이런 명령어가 주어졌을 때, 첫 번째 삭제 명령이 들어오기 전까지의 큐 상태는 최소큐 : [ -3, -3, -3, 2] 최대큐 : [-2, 3, 3, 3]D -1 이므로 최소큐에서 pop하게 되면 -3이 삭제되어 최소큐는 아래와 같이 된다. 최소큐 : [-3, -3, 2]그러나 최소큐와 최대큐는 사실 하나의 큐의 상태를 나타내고 있다. 그래서 최대큐에게 -3이 삭제되었다고 알려주어야 한다.그러한 기록을 하는 것이 map(check변수)이다. key : value = 삭제한 노드의 값(반대 부호) : 횟수를 의미한다. 노드의 값을 key로 하여 value를 조회했을 때check[value] = 디폴트 값인 0 : 삭제된 적이 없다는 것을 의미 양수 : 이전에 이미 삭제된 횟수를 의미여기서는 최소큐에서 -3을 삭제하였으니 이는 최대큐에서 3이라는 노드 하나를 삭제한 것과 같다.따라서 check 2 맵의 3을 key로 가지는 값을 하나 증가시켜 준다. (디폴트 값은 0으로 설정)check2[-value] += 1예를 들면 이런식으로 삭제했다는 것을 반대편의 큐에게 알려주는 것이다.반대로 최대큐에서 -2를 삭제했다면 사실상 2라는 노드를 제거한 것이므로 최소큐에게도 알려주어야 한다.이러한 check라는 map은 pop해야할 대상을 찾는 과정에서 사용된다. D 1 명령이 들어올 경우 바로 que2.pop() 하게 된다면 가장 앞에 있던 노드가 다른 큐에서 이미 삭제한 노드일 수도 있기 때문이다. 따라서 while문을 돌면서 우선순위큐의 가장 앞쪽 노드가 이미 삭제된 적이 있는지를 계속 검사하면서 삭제되지 않은 노드를 찾을 때까지 반복문을 계속하는 것이다. while문이 끝나면 삭제할 대상을 찾은 것이다. 대상을 찾았으니 위와 같이 다른 큐에게 삭제한 내용을 알려주고 마지막으로 pop을 하면 된다. I (value) 최소큐에는 양의 절댓값을, 최대큐에는 음의 절댓값을 삽입한다. D 1 : 최댓값을 삭제한다. 최대큐에서 pop하면서 pop할 대상을 찾는다. 이미 pop한 노드인 경우 건너뛴다. 최댓값을 최대 큐에서 삭제한다 삭제한 노드의 양의 절댓값을 최소큐에 표시한다. D -1 : 최소값을 삭제한다. 최소큐에서 pop하면서 pop할 대상을 찾는다. 이미 pop한 노드인 경우 건너뛴다. 최소값을 최소큐에서 pop한다. 삭제한 노드의 음의 절댓값을 최대큐에 표시한다. 파이썬 코드import heapqfrom collections import defaultdictdef solution(operations): answer = [0,0] que = [[],[]] # que[0] = 최소힙, que[1] = 최대힙 heapq.heapify(que[0]) heapq.heapify(que[1]) checked = [defaultdict(int), defaultdict(int)] # 삭제된 노드들을 기록하기 위한 각 큐의 기록 map cnt = 0 # cnt는 큐에 남아있는 노드의 개수를 의미한다. for op in operations: cmd, val = op.split() val = int(val) if cmd == &#39;I&#39;: cnt += 1 heapq.heappush(que[0], val) # 최소큐에는 양의 절댓값을 삽입 heapq.heappush(que[1], -val) # 최대큐에는 음의 절댓값을 삽입 else: if cnt == 0:continue # 큐에 남아있는 노드가 없으므로 삭제 명령 무시 cnt -= 1 if val &amp;lt; 0: # 최소값 삭제 명령 while checked[0][que[0][0]] &amp;gt; 0: # 삭제된 적이 없는 노드를 찾을 때까지 반복문 실행 checked[0][que[0][0]] += -1 heapq.heappop(que[0]) checked[1][-que[0][0]] += 1 #최대큐에게 삭제할 대상을 알려줌 heapq.heappop(que[0]) #최소큐의 가장 앞노드 삭제 else: # 최댓값 삭제 명령 while checked[1][que[1][0]] &amp;gt; 0: checked[1][que[1][0]] += -1 heapq.heappop(que[1]) checked[0][-que[1][0]] += 1 # 최소큐에게 삭제할 대상을 알려줌 heapq.heappop(que[1]) # 최대큐의 가장 앞노드 삭제 # que[0]에서는 최소값을, que[1]에서는 최댓값을 찾는다. while que[0] and checked[0][que[0][0]] &amp;gt; 0: checked[0][que[0][0]] += -1 heapq.heappop(que[0]) if que[0] != []: answer[1] = que[0][0] while que[1] and checked[1][que[1][0]] &amp;gt; 0: checked[1][que[1][0]] += -1 heapq.heappop(que[1]) if que[1] != []: answer[0] = -que[1][0] return answer추가프로그래머스에서 코드를 실행해보면 맞다고 나오는데 테스트 케이스가 적어서 좀 불안하다. 엣지 케이스가 더 많이 주어질 경우에 pop할 대상을 찾는 while문 부분에서 list out of index 에러가 날 것 같다." }, { "title": "Dijkstra 다익스트라 알고리즘 / GeeksforGeeks글 번역", "url": "/posts/dijkstra/", "categories": "알고리즘", "tags": "dijkstra, graph, geeksforgeeks, 번역", "date": "2022-02-20 00:00:00 +0900", "snippet": "0. Intro며칠 전에 풀었던 백준 1504번 문제를 풀 때 사용되었던 다익스트라에 대한 개념을 다시 한번 정리하려고 한다. GeeksforGeeks에서 소개되어 있는 다익스트라 알고리즘 문서를 영문 -&amp;gt; 한국어 번역한 포스트이다. 여기서부터 번역한 내용들이다.Dijkstra 다익스트라 알고리즘| 최단 거리 알고리즘, 그리디그래프와 시작 정점이 주어졌을 때, 시작점부터 주어진 그래프 내의 시작점 제외의 나머지 모든 점들까지의 최단 거리를 찾는 알고리즘이다. 다익스트라 알고리즘은 프림 알고리즘의 MST(최소 스패닝 트리)와 매우 비슷하다. 프림의 MST처럼 시작점을 루트 노드로 하는 SPT(shortest path tree : 최단 거리 트리)가 있다.두 가지 set이 필요하다. 1 : SPT에 포함된 노드들로 이루어진 set 2 : SPT에 아직 포함되지 않은 노드들로 이루어진 set알고리즘의 모든 단계에서 2번 set에 있는 노드들 중에서 시작점과 가장 가까이에 있는 점들을 찾는다.아래는 시작점에서 나머지 모든 점들까지의 최단 거리를 찾기 위한 세부적인 단계들이다. 위에서 언급한 1번 set(sptSet)을 만든다. sptSet은 이미 방문한 정점들로 이루어져 있다. 여기에 포함된 노드들과 - 시작점까지의 최단거리가 이미 계산이 완료된 정점들이다. 빈 set으로 초기화된다. 주어진 정점들까지의 거리를 할당한다. distance : 시작점과 정점까지의 거리를 나타내는 변수이다. 처음에는 무한대로 초기화한다. 시작점의 경우는 0으로 초기화한다. 시작점 -&amp;gt; 시작점까지의 거리는 0이니다. 이 시작점부터 먼저 탐색을 시작한다. While sptSet이 주어진 모든 정점들을 포함하고 있지 않을 때까지 = 모든 정점들을 방문할 때까지. sptSet에 아직 포함되지 않은 정점들을 고른다. 그러한 정점들이 여러 개일 경우 가장 짧은 정점을 고른다. 정점 u라고 가정 고른 정점 u를 sptSet에 포함한다. = 방문처리 u와 연결되어 있는 정점들까지의 거리를 distance 업데이트 한다. 단 조건이 있다. 시작점 - u까지의 거리 + u + u와 인접한 정점 v 까지의 거리가 기존의 시작점 - v까지의 거리보다 작을 경우에만 최단 거리를 갱신한다. 주어진 그래프주요 변수는 2 개이다. sptSet : 방문한 정점들을 포함한다. distance : 시작점 - 정점까지의 거리를 나타낸다.sptSet은 처음에는 빈 집합 {}으로 초기화 되고 distance는 {0,INF, INF, INF..}와 같이 시작점은 0으로 나머지는 INF로 초기화된다. 이제 시작점에서 최단 거리인 정점을 고른다. 0번 정점이 선택되고 sptSet에 추가하고 0의 인점 정점들과의 거리를 갱신한다. sptSet : {0}0과 인접한 정점들은 1과 7이다. 현재 distance에는 1과 7모두 처음의 값인 INF가 할당되어 있다. 시작점 - 현재까지의 거리 (0)에서 부터 1과 7까지의 거리를 더한 거리가 INF보다 작을 경우에 distance를 갱신한다. 1번 : 0 + 4 &amp;lt; INF 7번 : 0 + 8 &amp;lt; INF두 정점까지의 거리가 모두 INF모다 작으므로 = 더 짧은 거리이므로 거리를 갱신한다.방문한 정점(sptSet)은 초록색sptSet에 포함되지 않은 정점들 중에 가장 거리가 짧은 인접 정점을 선택한다. 1번 정점이 7번 정점보다 더 짧으므로 (4 &amp;lt; 8)선택되고 sptSet에 추가된다. sptSet : {0,1} 이제 1번과의 인접 노드들의 거리를 갱신한다. 1 -&amp;gt; 2의 거리는 8이고 1번까지의 거리는 이미 4로 갱신되어 있으므로 4 + 8 &amp;lt; IN로 더 짧다. 따라서 2번까지의 거리가 INF에서 12로 갱신된다.다시, sptSet에 포함되지 않은 정점들 중에 가장 거리가 짧은 인접 정점을 선택한다. 7번 정점이 sptSet에 추가된다. 앞의 단계에서 1번과 7번 중 1번이 더 짧으므로 선택되었으므로 다음으로 짧은 7번이 선택되는 것이다. sptSet : {0, 1, 7} 7번과의 인접 노드들의 거리를 갱신한다. 7번과 인접 정점들은 6과 8 이며 각각 거리가 9, 15로 모두 INF보다 짧다.다시, sptSet에 포함되지 않은 정점들 중에 가장 거리가 짧은 인접 정점을 선택한다. 6번이 선택된다. sptSet : {0, 1, 7, 6}이 되고 6번과 인접한 정점들까지의 거리를 갱신해준다. 5번과 8번이 갱신된다.위의 과정들을 sptSet에 모든 정점들이 포함될때까지 반복한다. 0과의 거리가 가장 짧은 정점 또는 방문하지 않은 정점을 고른다. = 방문한다. 그 점과 인버한 점들과의 거리를 (더 짧다면) 갱신한다.이 두가지를 계속 반복한다.모든 정점들이 방문되었고 그 옆의 숫자는 시작점(0)과의 거리를 나타낸다set이라고 표현했지만 구현은 배열로 했다. 정점 개수 v 길이의 배열을 만들고 각 정점에 해당하는 인덱스의 원소가 true이면 해당 정점은 방문되었다고 = sptSet에 포함된다고 친다. false이면 방문되지 않은 것이다. dist 배열 또한 같은 의미로 정점 = 인덱스로 하여 시작점 - 해당 정점까지의 거리를 나타내는 배열이다.아래는 GeeksforGeeks에서 제공하는 다익스트라 파이썬 코드이다. 정점을 찾고 거리를 갱신하는 과정을 반복하는 와중에 다음 정점을 찾을 때 모든 정점들을 순회하면서 정점을 찾는 부분이 효율적이지 못하다는 약점이 있지만 이후에 heap을 사용하면서 이부분을 줄일 수 있다. 또한 그래프를 2차원 행렬로 표현하고 있다.코드# Python program for Dijkstra&#39;s single# source shortest path algorithm. The program is# for adjacency matrix representation of the graph# Library for INT_MAXimport sysclass Graph(): def __init__(self, vertices): self.V = vertices self.graph = [[0 for column in range(vertices)] for row in range(vertices)] def printSolution(self, dist): print &quot;Vertex \\tDistance from Source&quot; for node in range(self.V): print node, &quot;\\t&quot;, dist[node] # A utility function to find the vertex with # minimum distance value, from the set of vertices # not yet included in shortest path tree def minDistance(self, dist, sptSet): # Initialize minimum distance for next node min = sys.maxint # Search not nearest vertex not in the # shortest path tree for u in range(self.V): if dist[u] &amp;lt; min and sptSet[u] == False: min = dist[u] min_index = u return min_index # Function that implements Dijkstra&#39;s single source # shortest path algorithm for a graph represented # using adjacency matrix representation def dijkstra(self, src): dist = [sys.maxint] * self.V dist[src] = 0 sptSet = [False] * self.V for cout in range(self.V): # Pick the minimum distance vertex from # the set of vertices not yet processed. # x is always equal to src in first iteration x = self.minDistance(dist, sptSet) # Put the minimum distance vertex in the # shortest path tree sptSet[x] = True # Update dist value of the adjacent vertices # of the picked vertex only if the current # distance is greater than new distance and # the vertex in not in the shortest path tree for y in range(self.V): if self.graph[x][y] &amp;gt; 0 and sptSet[y] == False and \\ dist[y] &amp;gt; dist[x] + self.graph[x][y]: dist[y] = dist[x] + self.graph[x][y] self.printSolution(dist)# Driver programg = Graph(9)g.graph = [[0, 4, 0, 0, 0, 0, 0, 8, 0], [4, 0, 8, 0, 0, 0, 0, 11, 0], [0, 8, 0, 7, 0, 4, 0, 0, 2], [0, 0, 7, 0, 9, 14, 0, 0, 0], [0, 0, 0, 9, 0, 10, 0, 0, 0], [0, 0, 4, 14, 10, 0, 2, 0, 0], [0, 0, 0, 0, 0, 2, 0, 1, 6], [8, 11, 0, 0, 0, 0, 1, 0, 7], [0, 0, 2, 0, 0, 0, 6, 7, 0] ];g.dijkstra(0);# This code is contributed by Divyanshu Mehta참고 위의 코드는 거리만 계산할 뿐 경로에 대한 정보는 계산하지 않는다. 또 하나의 배열을 추가해서 경로를 저장하고 갱신하는 과정을 추가할 수 있다. 따라서 시작점부터의 모든 정점들의 순서를 알 수 있다. 위의 코드는 무방향 그래프를 가정하고 있다. 하나의 정점 -&amp;gt; 여러 개의 도착점까지의 최단 거리를 구하고 있다. 그러나 하나의 도착점까지의 거리만을 구하고 싶다면 for문에서 중간에 break할 수도 있다. 시간 복잡도는 V^2이다. 만약 주어진 그래프가 인접리스트로 표현되었다면 E Log V로 줄일 수 있다. 다익스트라 알고리즘은 음의 가중치를 가진 그래프에는 적용되지 않는다. 하나의 정점을 여러 번 방문하는 방식으로 정답을 도출할 수도 있겠지만 그만큼 시간 복잡도가 나빠진다. 음의 가중치가 있을 경우 벨만-포드 알고리즘을 사용한다.다음 포스트 Dijkstra’s Algorithm for Adjacency List Representation : 인접 리스트로 표현된 다익스트라 알고리즘 Printing Paths in Dijkstra’s Shortest Path Algorithm : 다익스트라에서 경로(정점들의 순서)를 출력하기" }, { "title": "백준 1504 특정한 최단경로 문제 풀이", "url": "/posts/bj1504/", "categories": "알고리즘", "tags": "백준, ps, graph", "date": "2022-02-16 00:00:00 +0900", "snippet": "백준 1504 - 특정한 최단경로문제https://www.acmicpc.net/problem/1504방향이 없는 양의 정수의 거리로 이루어진 그래프가 주어진다. 1번부터 n번까지.1-&amp;gt;n 번 노드까지 가는 최단경로를 구하는 문제. 단, 특정 노드들을 꼭 거쳐 가야한다. v1,v2 두개의 노드를 거쳐 n까지 가는 최단 경로를 구한다.가능한 경로 경우의 수는 2가지 1 -&amp;gt; v1 -&amp;gt; v2 -&amp;gt; n 1 -&amp;gt; v2 -&amp;gt; v1 -&amp;gt; n1번과 2번 경로의 거리 중 짧은 것이 답이다. 다익스트라 알고리즘 시작점에서 다른 모든 점까지의 최단 거리를 구하는 알고리즘. N*N 위의 경우에서 시작점이 될 수 있는 경우는 1, v1, v2 이 3점이다. 다익스트라 알고리즘을 돌려 3개의 리스트를 반환받는다. 각 리스트는 각 시작점부터 다른 모든 점까지의 최단 거리가 갱신되어 있는 리스트이다. 3개의 리스트를 가지고 최단 거리를 구한다.만약 3과7을 거쳐서 9번까지 가는 최단 경로를 구하는 경우 dijkstra(1) -&amp;gt; a dijkstra(3) -&amp;gt; b dijkstra(7) -&amp;gt; c다익스트라를 세번 돌려서 최단 거리가 저장된 리스트를 얻는다.a[3] = 1 -&amp;gt; 3까지의 최단 거리b[7] = 3 -&amp;gt; 7까지의 최단 거리c[9] = 7 -&amp;gt; 9까지의 최단 거리이렇게 총 3개의 구간을 모두 더한다. v1, v2의 순서를 바꾸어 나머지 경로 경우의 수를 구하고 이 두 개 중에 더 작은 것이 정답이다.코드import heapqimport sysinput = sys.stdin.readlinen, e = map(int, input().split())graph = [ [0]*(n+1) for _ in range(n+1)]for _ in range(e): s, t, d = map(int, input().split()) graph[s][t] = d graph[t][s] = dv1, v2 = map(int, input().split())def dijkstra(start,graph): distance = [sys.maxsize] * (n+1) distance[start] = 0 que = [] heapq.heappush(que, (distance[start], start)) while que: dist, now = heapq.heappop(que) if distance[now] &amp;lt; dist:continue for i in range(1, n+1): if graph[now][i] == 0 or i == now:continue dd = dist + graph[now][i] if dd &amp;lt; distance[i]: distance[i] = dd heapq.heappush(que, (dd, i)) return distancepath = []for start in [1, v1, v2]: path.append(dijkstra(start, graph)) answer = min(path[0][v1] + path[1][v2] + path[2][n], path[0][v2] + path[2][v1] + path[1][n]) print(answer if answer &amp;lt; sys.maxsize else -1)" }, { "title": "백준 11404 플로이드 문제 풀이", "url": "/posts/bj11404/", "categories": "알고리즘", "tags": "백준, ps, graph", "date": "2022-02-05 00:00:00 +0900", "snippet": "백준 11404 - 플로이드문제https://www.acmicpc.net/problem/11404섬 = 노드, 버스 = 간선 형태의 그래프로 저장한다. 각 노드에서 모든 노드까지의 최소 비용을 구하는 문제이다. 플로이드-워셜 알고리즘을 이용하여 풀이. 플로이드-워셜 알고리즘 각 노드에서 모든 노드까지의 최단 경로를 구하는 알고리즘. 여기서는 단순히 비용만 구한다.코드n = int(input())m = int(input())cost = [ [999999999 for _ in range(n+1)] for _ in range(n+1)]for _ in range(m): s, e, c = map(int, input().split()) cost[s][e] = min(cost[s][e], c) for k in range(1, n+1): for i in range(1, n+1): for j in range(1, n+1): if i == j: cost[i][j] = 0 else: cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j])for row in cost[1:]: for col in row[1:]: print(col if col != 999999999 else 0, end=&#39; &#39;) print()" } ]
