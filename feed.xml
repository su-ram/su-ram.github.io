<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://su-ram.github.io/</id><title>수람</title><subtitle>A minimal, responsive, and powerful Jekyll theme for presenting professional writing.</subtitle> <updated>2023-06-04T23:15:33+09:00</updated> <author> <name>suram kim</name> <uri>https://su-ram.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://su-ram.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://su-ram.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2023 suram kim </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Leetcode | 2619. Array Prototype Last, 2620. Counter</title><link href="https://su-ram.github.io/posts/Leetcode-2619-Array-Prototype-Last/" rel="alternate" type="text/html" title="Leetcode | 2619. Array Prototype Last, 2620. Counter" /><published>2023-06-04T00:00:00+09:00</published> <updated>2023-06-04T23:14:49+09:00</updated> <id>https://su-ram.github.io/posts/Leetcode-2619-Array-Prototype-Last/</id> <content src="https://su-ram.github.io/posts/Leetcode-2619-Array-Prototype-Last/" /> <author> <name>suram kim</name> </author> <category term="알고리즘" /> <summary> 자바스크립트 easy 2문제를 풀었다. 2619. Array Prototype Last 자바스크립트 Array 객체의 프로토타입에 last 라는 새로운 메소드를 추가하는 것이 문제. last 함수는 배열의 마지막 값을 리턴한다. 빈 배열이면 -1. 간단하게는 삼항 연산자로 해결할 수 있지만, 나는 Nullish coalescing operator ?? 를 사용했다. Array.prototype.last = function() { return this.at(-1) ?? -1 }; 배열에 직접 인덱스로 접근할 때는 음수 인덱싱이 불가능하다. at() 메소드 사용할 때만 가능하다. 여기서 자바스크립트 개념과 연결해볼만 한 부분은 this 객체. Array 프로토타입 내의 메소드들의 th... </summary> </entry> <entry><title>Vue | useStore()를 사용하는 이유</title><link href="https://su-ram.github.io/posts/vue-useStore/" rel="alternate" type="text/html" title="Vue | useStore()를 사용하는 이유" /><published>2023-05-29T00:00:00+09:00</published> <updated>2023-05-29T22:23:36+09:00</updated> <id>https://su-ram.github.io/posts/vue-useStore/</id> <content src="https://su-ram.github.io/posts/vue-useStore/" /> <author> <name>suram kim</name> </author> <category term="Vue" /> <summary> Vue에서 store 접근하기 보통 프론트앱에서 데이터의 변경을 감지하고 추적하는 상태관리가 필요한 데이터들은 store에 보관하여 사용한다. store 객체를 생성하고 이를 vue app에 전역적으로 등록한다. 그러면 컴포넌트에서 해당 store에 접근하여 데이터를 get, mutation 등등의 작업을 할 수 있다. 보통은 store에 접근하는 방법은 다음과 같다. composition api 기준 vue app에 전역적으로 등록한 store를 this를 통해 접근하는 경우 setup() { const some = computed(() =&amp;gt; this.$store.getters.something) } store 객체를 직접 다이렉트로 import 하는 경우 im... </summary> </entry> <entry><title>JS | scoping 유효범위</title><link href="https://su-ram.github.io/posts/JS-%EB%B3%80%EC%88%98-%EC%9C%A0%ED%9A%A8%EB%B2%94%EC%9C%84/" rel="alternate" type="text/html" title="JS | scoping 유효범위" /><published>2023-02-13T00:00:00+09:00</published> <updated>2023-05-29T21:58:34+09:00</updated> <id>https://su-ram.github.io/posts/JS-%EB%B3%80%EC%88%98-%EC%9C%A0%ED%9A%A8%EB%B2%94%EC%9C%84/</id> <content src="https://su-ram.github.io/posts/JS-%EB%B3%80%EC%88%98-%EC%9C%A0%ED%9A%A8%EB%B2%94%EC%9C%84/" /> <author> <name>suram kim</name> </author> <category term="JS" /> <summary> 유효 범위 scoping 기본적으로 var 키워드로 선언된 변수는 함수 레벨 스코프이다. 자바스크립트에서는 함수 레벨 스코프 (function scoping)와 블록 레벨 스코프 (block scoping)로 나뉜다. 함수 레벨 스코프 : 변수에 접근할 수 있는 범위가 변수가 선언된 함수로 한정된다. 블록 레벨 스코프 : 변수에 접근할 수 있는 범위가 {} 블록 내부로 한정된다. // function scoping run = function() { if (true) { var bar = 'bar' } console.log(bar) } run() // 'bar' var은 if 블록이 아닌 함수 내부 전체 에서 접근가... </summary> </entry> <entry><title>JS | 선언과 할당 관점에서 본 호이스팅 개념과 이유</title><link href="https://su-ram.github.io/posts/JS-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85/" rel="alternate" type="text/html" title="JS | 선언과 할당 관점에서 본 호이스팅 개념과 이유" /><published>2023-02-09T00:00:00+09:00</published> <updated>2023-02-13T16:17:01+09:00</updated> <id>https://su-ram.github.io/posts/JS-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85/</id> <content src="https://su-ram.github.io/posts/JS-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85/" /> <author> <name>suram kim</name> </author> <category term="JS" /> <summary> 기존의 변수 선언 방식 모든 프로그래밍 언어에서의 변수는 선언 -&amp;gt; 할당 -&amp;gt; 사용의 과정을 거친다. 그리고 선언되어있지 않은 변수는 할당도, 사용도 불가능하다. 즉, 사전에 선언이 되어 있어야 사용이 가능하다. 자바스크립트에서는 이러한 과정에서 호이스팅이란 개념이 존재한다. 호이스팅 hoisting 호이스팅은 코드의 실행 전에, 변수의 선언 관련 정보를 미리 수집하여 실행 전에 변수에 접근할 수 있도록 하는 과정이다. MDN에서는 ‘인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것을 의미’라고 설명하고 있다. 보통 호이스팅 관련한 글들을 보면 변수의 선언부를 끌어올린다는 표현을 많이 쓴다. 아마 hoist 라는 단어의 뜻 때문인 것 같다. 무언가를 끌어올린다는 사... </summary> </entry> <entry><title>왜 원시형 데이터는 스택에, 참조형 데이터는 힙에 저장할까?</title><link href="https://su-ram.github.io/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%8B%A4%ED%96%89%EA%B3%BC-%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%95%A0%EB%8B%B9/" rel="alternate" type="text/html" title="왜 원시형 데이터는 스택에, 참조형 데이터는 힙에 저장할까?" /><published>2023-01-24T00:00:00+09:00</published> <updated>2023-01-29T23:42:53+09:00</updated> <id>https://su-ram.github.io/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%8B%A4%ED%96%89%EA%B3%BC-%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%95%A0%EB%8B%B9/</id> <content src="https://su-ram.github.io/posts/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%8B%A4%ED%96%89%EA%B3%BC-%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%95%A0%EB%8B%B9/" /> <author> <name>suram kim</name> </author> <category term="프로그래밍" /> <summary> Intro 원시형 데이터는 스택에, 참조형 데이터는 힙에 저장된다. 스택은 힙보다 빠르고, 작다. 대부분의 언어에서 일반적으로 이런 방식으로 데이터를 할당한다. 한 단계 더 깊이 생각해보면, 스택과 힙에 대해서 궁금한 점들이 생긴다. 정말 모든 원시형 데이터는 모조리 다 스택에, 모든 참조형 데이터는 모조리 다 힙에 저장되는 걸까? 참조형 데이터인 객체도 내부 속성으로 원시형 데이터를 갖고 있는데 그럼 이 내부 속성의 원시형 데이터는 스택/힙 중에 어디에 저장되는 걸까? 여기서 말하는 스택이 콜스택을 말하는 건가? 왜 스택은 힙보다 빠르고, 용량이 더 적을까? 근본적으로 왜 다른 메모리 공간에 각각 데이터를 저장하도록 되어있을까? 데이터 타입에 따라 메모리 어디에 할... </summary> </entry> </feed>
