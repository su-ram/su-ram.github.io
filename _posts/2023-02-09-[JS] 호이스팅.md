---
title: JS | 호이스팅 개념과 이유
categories: [JS]
tags: [JS, Javascript, var, let, const, hoisting, 호이스팅]
---

## 기존의 변수 선언 방식 <kbd>var</kbd>

자바스크립트 환경에서 변수를 선언하는 전통적인 키워드는 `var` 이다. 그러나 이 녀석 `var`를 아무 생각 없이, 막연하게 사용하다보면 내 의도와는 다르게 동작하는 경우가 있다. 

## var의 한계점

1. 유효 범위 scoping
    
    기본적으로 `var` 키워드로 선언된 변수는 **함수 레벨 스코프**이다. 자바스크립트에서는 함수 레벨 스코프 (function scoping)와 블록 레벨 스코프 (block scoping)로 나뉜다. 
    - 함수 레벨 스코프 : 변수에 접근할 수 있는 범위가 변수가 선언된 함수로 한정된다. 
    - 블록 레벨 스코프 : 변수에 접근할 수 있는 범위가 `{}` 블록 내부로 한정된다. 

    ```javascript
    // function scoping
    run = function() {
     if (true) {
        var bar = 'bar'
     }
     console.log(bar)
    }
    run() // 'bar' 
    ```
    `var`은 if 블록이 아닌 함수 내부 전체 에서 접근가능하기 때문에 if 블록이 종료되어도 접근할 수 있다. 따라서 'bar' 출력. 

     ```javascript
    // block scoping
    run = function() {
     if (true) {
        let bar = 'bar'
     }
     console.log(bar)
    }
    run() // ReferenceError: bar is not defined
    ```
    `let`은 블록 레벨 스코프이기 때문에 if블록 내에서만 유효하다. 따라서 if문 종료후에는 접근할 수 없으므로 에러가 발생한다. 

    `var`는 함수 레벨 스코프이기 때문에 **블록 내부의 변수가 블록 외부에까지 영향을 미칠 수 있다는 점**을 알아야 한다. 이는 코드의 추적을 방해하고, 예측하지 못한 결과를 만들 수도 있다. 모든 변수이름을 다 머리 속에 저장하고 코드를 작성하지 않으므로 충분히 중복된 변수명을 사용할 수 있다. 또한, `var`로 선언한 변수는 전역 객체에 등록된다는 점도 같은 맥락에서 이해할 수 있다. 
    
    정리하자면, 
    - 내가 사용한 변수의 유효범위를 정확하게 제한하거나 예측할 수 없다.
    - 전역 객체에 등록되어 전역변수로 사용된다.


2. 호이스팅 hoisting  

    `var`로 선언된 변수는 **호이스팅의 대상**이된다. 호이스팅은 코드의 실행 전에, 변수의 선언 관련 정보를 미리 수집하여 실행 전에 변수에 접근할 수 있도록 하는 과정이다. MDN에서는 '인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것을 의미'라고 설명하고 있다. 

    보통 호이스팅 관련한 글들을 보면 `변수의 선언부를 끌어올린다`는 표현을 많이 쓴다. 아마 `hoist` 라는 단어의 뜻 때문인 것 같다. 무언가를 끌어올린다는 사전적 의미를 갖고 있다.
    
    > hoist : (noun) an act of raising or lifting something.

    코드는 순차적이기 때문에 위/아래가 존재한다. 컴파일러/인터프리터는 위에서부터 아래로 순차적으로 코드를 해석한다. 따라서 이미지상으로 하단의(즉, 미래의) 변수들을 상단으로(현재) 끌어올린다는 그림이 이상하지가 않는 것이다. 

    ```javascript  
    run = function() {
        console.log(foo)
        var foo = 'foo' // 데이터 선언과 할당이 동시에 이루어진 코드.
    }
    run() // 'undefined'
    ```
    `foo` 를 선언하기 이전에 콘솔에 찍어보면 undefined를 출력한다. 컴파일러가 코드를 실행하기 전에, 변수의 선언 정보들만 미리 스캔한다. `var foo = 'foo'` 이 부분에서 **선언부분만 수집**하게 되어, `foo` 변수를 메모리에 할당하고 문자열 'foo'를 할당하는 부분은 무시하고 디폴트값인 `undefined`를 할당한다.

    ```javascript
    run = function() {
        var foo; // 선언 후 undefined로 자동 할당
        console.log(foo) // undefined 출력
        foo = 'foo' // 값 할당
    }
    ```
    컴파일러가 동작하는 과정을 코드의 순차적인 흐름으로 표현해보자면 위와 같은 순서로 실행된다고 보면 된다. 그러면, 
    
## 왜 호이스팅 과정이 발생하는 걸까?

왜 이렇게 자바스크립트는 성격이 급해서 코드 실행도 전에 변수에 접근할 수 있도록 해주는 걸까? 자바스크립트의 창조주 브렌든 아이크님이 직접 답을 해주신 트윗을 발견했다. 진짜가 나타났다. 질문자님이 내가 가진 궁금증을 다 물어봐주셔서 속이 시원했다. 왜 이렇게 디자인되었는지가 궁금했다. 

![호이스팅이유](https://user-images.githubusercontent.com/20367043/218270292-aa155bf4-55a9-466b-b736-eb523d65fbf0.png){: .shadow}_[해당 트윗 링크](https://twitter.com/BrendanEich/status/522394590301933568)_
    
Q : 왜 자바스크립트는 호이스팅을 하나요? 왜 자바스크립트는 그런 방식으로 설계되었나요? 그러한 설계 방식은 무엇의 영향을 받았나요?

> A : 
> 함수 호이스팅으로 인해 다음 3가지를 할 수 있다. 
> - 탑다운 방식의 프로그램 구조 분해 
> - 'let rec'를 자유롭게 사용하는 것
> - 함수 선언 전에 함수 호출
> 
> 변수에 대한 호이스팅은 다음 3가지의 의한 의도하지 않은 결과물이다. 
> - 함수 호이스팅
> - 블록 레벨 스코프가 아님
> - 1995년에 급하게 작업한 결과
> 
> `let`이 도움이 될 것이다.

원래 호이스팅의 목적은 함수였다. 처음엔 함수만을 생각하고 설계했지만 변수에도 영향이 간 것으로 보인다. 생각해보면, 함수를 호출하기 위한 필수 사전조건은 함수가 정의되어 있어야한다 (=선언되어 있어야 한다.) 프로그램 내부에서 수많은 함수들이 호출될텐데, 각 함수들의 선언 순서를 모두 기억하고 순서에 따라 함수 호출을 제어한다는 것은 불가능하다. 그래서 개발자가 함수의 호출 순서에 구애받지 않고 개발하려면 모든 함수를 사전에 알고 있으면 좋지 않을까 하는 생각에서 이러한 설계가 나오지 않았을까 싶다.     

## let, const



## TDZ


